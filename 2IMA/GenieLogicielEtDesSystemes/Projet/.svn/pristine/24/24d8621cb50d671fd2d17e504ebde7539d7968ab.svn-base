import game : 'model/generated/Game.ecore'

package game

context Jeu
	-- Le nom ne doit pas etre vide
	inv nomVide: name <> ''

context Composant
	-- Le nom ne doit pas etre vide
	inv nomVide: name <> ''

context Territoire
	-- Les lieux et chemins ne doivent pas avoir le meme nom
	inv composantsNomsIdentiques: composants-> forAll(a,b|a <> b implies a.name <> b.name)
	-- Les lieux et chemins ne doivent pas etre inscrit deux fois
	inv composantsIdentiques: composants-> forAll(a,b|a <> b)
	-- Le territoire possede un depart et il est unique
	inv unDepart: composants	-> select(co|co.oclIsTypeOf(Lieu))
								-> collect(co|co.oclAsType(Lieu))
								-> select(l|l.type = Extremite::Depart)
								-> size() = 1
	-- Le territoire possede une ou plusieurs fins
	inv uneArrivee: composants	-> select(co|co.oclIsTypeOf(Lieu))
								-> collect(co|co.oclAsType(Lieu))
								-> select(l|l.type = Extremite::Fin)
								-> size() >= 1

context ComposantTerritoire
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)

context Lieu
	-- La meme personne ne peut etre presente qu'une fois dans un lieu
	inv personnesIdentiques: personnes-> forAll(a,b|a <> b)
	-- Une seule personne obligatoire par lieu
	inv uneObligatoire: personnes-> select(pe|pe.obligation = Obligation::Obligatoire)-> size() <= 1
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a <> b)

context DescriptionConditionnee
	-- La description ne doit pas etre vide
	inv descriptionVide: description <> ''
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a <> b)

context Chemin
	-- Le lieu de debut et de fin doivent etre different
	inv lieuxIdentiques: depart <> fin
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditionsOuverture-> forAll(a,b|a <> b) and conditionsVisibilite-> forAll(a,b|a <> b)

context Personne
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)
	-- Toutes les choix doivent etre differents
	inv choixIdentiques: choix-> forAll(a,b|a <> b)

context Explorateur
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)
	-- La charge de l'explorateur est positive ou nulle (si il ne peut rien porter)
	inv poids: poidsMax >= 0

context Possession
	-- Une possession est soit une connaissance soit un objet
	inv connaissanceOuObjet: connaissance <> null xor self.oclIsTypeOf(Objet)

context PossessionConditionnee
	-- Toutes les conditions doivent etre differentes.
	inv conditionsIdentiques: conditions-> forAll(a,b|a <> b)

context Connaissance
	-- Toutes les conditions doivent etre differentes
	inv conditionsVisibiliteIdentiques: conditionsVisibilite-> forAll(a,b|a <> b)

context Objet
	-- Un objet represente une quantite ou une absence d'objets elementaires
	inv quantitePositive: quantite >= 0

context ObjetElementaire
	-- La taille de l'objet est positive ou nulle
	inv taillePositive: taille >= 0
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditionsVisibilite-> forAll(a,b|a <> b) and conditionsTransformabilite-> forAll(a,b|a <> b)

context Transformation
	-- Toutes les conditions doivent etre differentes.
	inv conditionsIdentiques: conditions-> forAll(a,b|a <> b)
	-- Tous les objets doivent etre differents.
	inv objetsIdentiques: objets-> forAll(a,b|a <> b)

context Condition
	-- Toutes les conditions doivent etre differentes.
	inv conditionsIdentiques: conditions-> forAll(a,b|a <> b)
	-- Toutes les possessions doivent etre differentes.
	inv possessionsIdentiques: possessions-> forAll(a,b|a <> b)
	-- Toutes les difficultes doivent etre differentes.
	inv difficultesIdentiques: difficulte-> forAll(a,b|a <> b)
	-- Une probabilite est forcement positive
	inv probabilitePositive: probabilite >= 0
	

endpackage