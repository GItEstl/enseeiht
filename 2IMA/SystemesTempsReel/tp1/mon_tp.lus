node rising_edge (X: bool) returns (Y: bool)
let
    Y = X -> (X and not pre(X));
tel ;


node falling_edge (X: bool) returns (Y: bool)
let
    Y = not X -> (not X and pre(X));
tel ;

node verif(X: bool) returns (Y: bool)
var P1, P2: bool;
let
    P1 = rising_edge(X) = falling_edge(not X);
    P2 = rising_edge(not X) = falling_edge(X);
    Y = P1 and P2;
tel ;

node counter(const N: int ; RAZ: bool) returns (T: bool)
var counter_state: int;
let
    counter_state = 0 -> if RAZ then 0 else if pre(counter_state) = N then N else pre(counter_state) + 1;
    T = false -> counter_state = N;
tel ;

node simu_counter(RAZ: bool) returns (T: bool)
let
    T = counter(3, RAZ);
tel ;
