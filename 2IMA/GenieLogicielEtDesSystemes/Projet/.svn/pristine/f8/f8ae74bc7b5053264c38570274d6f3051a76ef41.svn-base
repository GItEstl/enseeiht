import game : 'model/generated/Game.ecore'

package game

context Jeu
	-- Le nom ne doit pas etre vide
	inv nomVide: name <> ''

context Composant
	-- Le nom ne doit pas etre vide
	inv nomVide: name <> ''

context Territoire
	-- Les lieux et chemins ne doivent pas avoir le meme nom
	inv composantsNomsIdentiques: composants-> forAll(a,b|a.name = b.name implies a = b)
	-- Les lieux et chemins ne doivent pas etre inscrit deux fois
	inv composantsIdentiques: composants-> forAll(a,b|a <> b)
	-- Le territoire possede un depart et il est unique
	inv unDepart: composants	-> select(co|co.oclIsTypeOf(Lieu))
								-> collect(co|co.oclAsType(Lieu))
								-> select(l|l.type = Extremite::Depart)
								-> size() = 1
	-- Le territoire possede une ou plusieurs fins
	inv uneArrivee: composants	-> select(co|co.oclIsTypeOf(Lieu))
								-> collect(co|co.oclAsType(Lieu))
								-> select(l|l.type = Extremite::Fin)
								-> size() >= 1

context ComposantTerritoire
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)

context Lieu
	-- La meme personne ne peut etre presente qu'une fois dans un lieu
	inv personnesIdentiques: personnes-> forAll(a,b|a.name = b.name implies a = b)
	-- Une seule personne obligatoire par lieu
	inv uneObligatoire: personnes-> select(pe|pe.obligation = Obligation::Obligatoire)-> size() <= 1
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)

context DescriptionConditionnee
	-- La description ne doit pas etre vide
	inv descriptionVide: description <> ''
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)

context Chemin
	-- Le lieu de debut et de fin doivent etre different
	inv lieuxIdentiques: depart <> fin
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditionsOuverture-> forAll(a,b|a.name = b.name implies a = b)
						  and conditionsVisibilite-> forAll(a,b|a.name = b.name implies a = b)

context Personne
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)
	-- Toutes les choix doivent etre differents
	inv choixIdentiques: choix-> forAll(a,b|a.name = b.name implies a = b)
	-- La personne possede un ou plusieurs choix de depart
	inv unDepart: choix	-> select(c|c.type = Extremite::Depart)
						-> size() >= 1
	-- Doit-on faire une closure pour voir qu'on peut avoir une fin ou laisse t on ca au petri?

context Explorateur
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a.possession <> b.possession)
	-- La charge de l'explorateur est positive ou nulle (si il ne peut rien porter)
	inv poids: poidsMax >= 0

context Possession
	-- Une possession est soit une connaissance soit un objet
	inv connaissanceOuObjet: connaissance <> null xor self.oclIsTypeOf(Objet)

context PossessionConditionnee
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)

context Connaissance
	-- Toutes les conditions doivent etre differentes
	inv conditionsVisibiliteIdentiques: conditionsVisibilite-> forAll(a,b|a.name = b.name implies a = b)

context Objet
	-- Un objet represente une quantite ou une absence d'objets elementaires
	inv quantitePositive: quantite >= 0

context ObjetElementaire
	-- La taille de l'objet est positive ou nulle
	inv taillePositive: taille >= 0
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditionsVisibilite-> forAll(a,b|a.name = b.name implies a = b)
						  and conditionsTransformabilite-> forAll(a,b|a)

context Transformation
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)
	-- Tous les objets doivent etre differents.
	inv objetsIdentiques: objets-> forAll(a,b|a.objet <> b.objet)

context Condition
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)
	-- Une condition ne doit pas boucler
	inv pasBoucle: conditions-> closure(a | a.conditions)-> forAll(a| a.name <> self.name)
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|a <> b)
	-- Toutes les difficultes doivent etre differentes
	inv difficultesIdentiques: difficulte-> forAll(a,b|a <> b)
	-- Une probabilite est forcement positive
	inv probabilitePositive: probabilite >= 0 and probabilite <= 100

context Comparaison
	-- Une comparaison est soit une connaissance soit un comparateur et un objet
	inv connaissanceOuObjet: connaissance <> null xor (comparateur <> null and objet <> null)

context Choix
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)
	-- Toutes les actions doivent etre differentes.
	inv actionsIdentiques: actions-> forAll(a,b|a.action = b.action implies a = b)

context ChoixConditionne
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)
	-- Tous les choix doivent etre differents entre eux et du choix qualifie.
	inv choixIdentiques: choixPrecedents-> forAll(a,b|a <> b) and choixPrecedents-> forAll(a|a <> choix)

context Action
	-- Toutes les possessions doivent etre differentes
	inv possessionsIdentiques: possessions-> forAll(a,b|true)
	-- Tous les objets consommes doivent etre differents
	inv objetsIdentiques: objetsConsommes-> forAll(a,b|a.objet <> b.objet)	

context ActionConditionnee
	-- Toutes les conditions doivent etre differentes
	inv conditionsIdentiques: conditions-> forAll(a,b|a.name = b.name implies a = b)
	-- Toutes les choix doivent etre differents
	inv choixIdentiques: choixPrecedents-> forAll(a,b|a <> b) and choixOfferts-> forAll(a,b|a.choix <> b.choix)

endpackage